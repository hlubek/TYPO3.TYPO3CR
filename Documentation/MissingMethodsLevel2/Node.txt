== Node ==

=== Node addNode(String relPath) ===
Creates a new node at relPath. The new node will only be persisted on 
save if it meets the constraint criteria of the parent node's node type. 
In order to save a newly added node, save must be called either on the 
Session, or on the new node's parent or higher-order ancestor 
(grandparent, etc.). An attempt to call save only on the newly added 
node will throw a RepositoryException. 
In the context of this method the relPath provided must not have an 
index on its final element. If it does then a RepositoryException is 
thrown. 
Strictly speaking, the parameter is actually a relative path to the parent 
node of the node to be added, appended with the name desired for the 
new node (if the node is being added directly below this node then only 
the name need be specified). It does not specify a position within the 
child node ordering (if such ordering is supported). If ordering is 
supported by the node type of the parent node then the new node is 
appended to the end of the child node list. 
Since this signature does not allow explicit node type assignment, the 
new node's primary node type will be determined (either immediately or 
on save depending on the implementation) by the child node definitions 
in the node types of its parent. See 5.6.2 Assigning a Primary Node 
Type. 
An ItemExistsException will be thrown either immediately (by this 
method), or on save, if an item at the specified path already exists and 
same-name siblings are not allowed. Implementations may differ on 
when this validation is performed. 
A PathNotFoundException will be thrown either immediately (by this 
method), or on save, if the specified path implies intermediary nodes 
that do not exist. Implementations may differ on when this validation is 
performed. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if adding the node would violate a node 
type or implementation-specific constraint or if an attempt is made to 
add a node as the child of a property. Implementations may differ on 
when this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if the node to which the new child is being added 
is versionable and checked-in or is non-versionable but its nearest 
versionable ancestor is checked-in. Implementations may differ on when 
this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the addition of the node. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs. 

=== Node addNode(String relPath, String primaryNodeTypeName) ===
Creates a new node at relPath of the specified primary node type. 
The same as addNode(String relPath) except that the primary node 
type of the new node is explicitly specified. 
An ItemExistsException will be thrown either immediately (by this 
method), or on save, if an item at the specified path already exists and 
same-name siblings are not allowed. Implementations may differ on 
when this validation is performed. 
A PathNotFoundException will be thrown either immediately (by this 
method), or on save, if the specified path implies intermediary nodes 
that do not exist. Implementations may differ on when this validation is 
performed. 
A NoSuchNodeTypeException will be thrown either immediately (by this 
method), or on save, if the specified node type is not recognized. 
Implementations may differ on when this validation is performed. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if adding the node would violate a node 
type or implementation-specific constraint or if an attempt is made to 
add a node as the child of a property. Implementations may differ on 
when this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if the node to which the new child is being added 
is versionable and checked-in or is non-versionable but its nearest 
versionable ancestor is checked-in. Implementations may differ on when 
this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the addition of the node. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs. 

=== Property setProperty(String name, Value value) ===
Sets the specified (single value) property of this node to the specified 
value. If the property does not yet exist, it is created. The property 
type of the property will be that specified by the node type of this node. 
If the property type of the supplied Value object is different from that 
required, then a best-effort conversion is attempted. If the conversion 
fails, a ValueFormatException is thrown. If another error occurs, a 
RepositoryException is thrown. 
If the node type of this node does not indicate a specific property type, 
then the property type of the supplied Value object is used and if the 
property already exists (has previously been set) it assumes both the 
new value and new property type. If the property is multi-valued, a 
ValueFormatException is thrown. 
Passing a null as the second parameter removes the property. It is 
equivalent to calling remove on the Property object itself. For example, 
N.setProperty("P", (Value)null) would remove property called "P" 
of the node in N. 
To save the addition or removal of a property, a save call must be 
performed that includes the parent of the property in its scope: that is, 
a save on either the session, this node, or an ancestor of this node. To 
save a change to an existing property, a save call that includes that 
property in its scope is required. This means that in addition to the 
above-mentioned save options, a save on the changed property itself 
will also work. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if the change would violate a node type or 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the setting of the property. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs. 

=== Property setProperty(String name, Value[] values) ===
Sets the specified (multi-value) property to the specified array of 
values. If the property does not yet exist, it is created. Same as 
setProperty(String name, Value value) except that an array of 
Value objects is assigned instead of a single Value. 
The property type of the property will be that specified by the node type 
of this node. If the property type of the supplied Value objects is 
different from that required, then a best-effort conversion is attempted. 
If the conversion fails, a ValueFormatException is thrown. All Value 
objects in the array must be of the same type, otherwise a 
ValueFormatException is thrown. If the property is not multi-valued 
then a ValueFormatException is also thrown. If another error occurs, a 
RepositoryException is thrown. 
If the node type of this node does not indicate a specific property type, 
then the property type of the supplied Value objects is used and if the 
property already exists it assumes both the new values and the new 
property type. 
Passing a null as the second parameter removes the property. It is 
equivalent to calling remove on the Property object itself. For example, 
N.setProperty("P", (Value[])null) would remove property called 
"P" of the node in N.
Note that this is different from passing an array that contains 
null elements. In such a case, the array is compacted by removing the 
nulls. The resulting set of values of the property never contains nulls. 
However, the set may be empty: N.setProperty("P", new 
Value[]{null}) would set the property to the empty set of values. 
To save the addition or removal of a property, a save call must be 
performed that includes the parent of the property in its scope: that is, 
a save on either the session, this node, or an ancestor of this node. To 
save a change to an existing property, a save call that includes that 
property in its scope is required. This means that in addition to the 
above-mentioned save options, a save on the changed property itself 
will also work. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if the change would violate a node type or 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the setting of the property. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs.  

=== Property setProperty(String name, Value[] values, int type) ===
Sets the specified (multi-value) property to the specified array of 
values. If the property does not yet exist, it is created. The type of the 
property is determined by the type parameter specified. 
If the property type of the supplied Value objects is different from that 
specified, then a best-effort conversion is attempted. If the conversion 
fails, a ValueFormatException is thrown. 
If the property already exists it assumes both the new values and the 
new property type. 
All Value objects in the array must be of the same type, otherwise a 
ValueFormatException is thrown. If the property is not multi-valued 
then a ValueFormatException is also thrown. If another error occurs, a 
RepositoryException is thrown. 
Passing a null as the second parameter removes the property. It is 
equivalent to calling remove on the Property object itself. For example, 
N.setProperty("P", (Value[])null, type) would remove property 
called "P" of the node in N. 
Note that this is different from passing an array that contains 
null elements. In such a case, the array is compacted by removing the 
nulls. The resulting set of values of the property never contains nulls. 
However, the set may be empty: N.setProperty("P", new 
Value[]{null}, type) would set the property to the empty set of 
values. 
To save the addition or removal of a property, a save call must be 
performed that includes the parent of the property in its scope: that is, 
a save on either the session, this node, or an ancestor of this node. To 
save a change to an existing property, a save call that includes that 
property in its scope is required. This means that in addition to the 
above-mentioned save options, a save on the changed property itself 
will also work. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if the change would violate a node type or 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the setting of the property. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs.  

=== Property setProperty(String name, String[] values) ===
Sets the specified property to the specified array of values. Same as 
setProperty(String name, Value[] values) except that the values are specified as 
String objects instead of Value objects. 
 
=== Property setProperty(String name, String[] values, int type) ===
Sets the specified property to the specified array of values and to the 
=== specified type. Same as setProperty(String name, Value[] values, int type) ===
except that the values are specified as String objects instead of Value 
objects. 
 
=== Property setProperty(String name, Value value, int type) ===
Sets the specified (single-value) property to the specified value. If the 
property does not yet exist, it is created. The type of the property is 
determined by the type parameter specified. 
If the property type of the supplied Value object is different from that 
required, then a best-effort conversion is attempted. If the conversion 
fails, a ValueFormatException is thrown. 
If the property is not single-valued then a ValueFormatException is 
also thrown. 
If the property already exists it assumes both the new value and the 
new property type. 
Passing a null as the second parameter removes the property. It is 
equivalent to calling remove on the Property object itself. For example, 
N.setProperty("P", (Value)null, type) would remove property 
called "P" of the node in N. 
To save the addition or removal of a property, a save call must be 
performed that includes the parent of the property in its scope: that is, 
a save on either the session, this node, or an ancestor of this node. To 
save a change to an existing property, a save call that includes that 
property in its scope is required. This means that in addition to the 
above-mentioned save options, a save on the changed property itself 
will also work. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if the change would violate a node type or 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the setting of the property. Implementations 
may differ on when this validation is performed. 
If another error occurs, a RepositoryException is thrown.  

=== Property setProperty(String name, String value, int type) ===
Sets the specified property to the specified value. Same as 
setProperty(String name, Value value, int type)
except that the value is specified as a String object instead of a Value 
object. 
 
=== Property setProperty(String name, String value) ===
=== Property setProperty(String name, InputStream value) ===
=== Property setProperty(String name, boolean value) ===
=== Property setProperty(String name, Calendar value) ===
=== Property setProperty(String name, double value) ===
=== Property setProperty(String name, long value) ===
=== Property setProperty(String name, Node value) ===
Sets the specified property to the specified value. In the context of 
these methods, each Java type implies a particular property type. The 
correspondence is: 
String: PropertyType.STRING 
InputStream: PropertyType.BINARY 
boolean: PropertyType.BOOLEAN 
Calendar: PropertyType.DATE 
double: PropertyType.DOUBLE 
long: PropertyType.LONG 
Node: PropertyType.REFERENCE 
In the case of the signature that takes an InputStream, the passed 
stream is closed before this method returns either normally or because 
of an exception. 
In the case of the signature that takes a Node, the REFERENCE property 
in question is set to refer to the supplied node (see 4.2.6.4 Reference). 
The property type of the property being set is determined by the node 
type of this node. If this property type is something other than that 
implied by the (Java) type of the passed value, a best-effort conversion 
is attempted. If the conversion fails, a ValueFormatException is 
thrown. If the property is multi-valued, a ValueFormatException is also 
thrown. If another error occurs, a RepositoryException is thrown. 
If the node type of this node does not specify a particular property 
type for the property being set then the property type implied by the 
(Java) type of the passed value is used and if the property already 
exists (has previously been set) it assumes both the new value and new 
type. 
Passing a null as the second parameter removes the property. It is 
equivalent to calling remove on the Property object itself. For example, 
N.setProperty("P", (Calendar)null) would remove property called 
"P" of the node in N. Obviously, a null cannot be passed to the 
signatures that take the primitive types boolean, long or double. 
To save the addition or removal of a property, a save call must be 
performed that includes the parent of the property in its scope: that is, 
a save on either the session, this node, or an ancestor of this node. To 
save a change to an existing property, a save call that includes that 
property in its scope is required. This means that in addition to the 
above-mentioned save options, a save on the changed property itself 
will also work. 
The property types NAME, PATH, URI and WEAKREFERENCE do not have 
implicit set methods. A property of one of these types may be created 
either by explicitly specifying the property type using a three-argument 
setProperty signature, or by using ValueFactory to create a property 
of the desired type and then calling setProperty(String, Value). 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if the change would violate a node type or 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the setting of the property. Implementations 
may differ on when this validation is performed. 
A RepositoryException is thrown if another error occurs. 

=== void update(String srcWorkspaceName) ===
If this node does have a corresponding node in the workspace 
srcWorkspaceName, then this replaces this node and its subtree with a 
clone of the corresponding node and its subtree. 
If this node does not have a corresponding node in the workspace 
srcWorkspaceName, then the update method has no effect. 
If the update succeeds, the changes made to this node and its subtree 
are persisted immediately, there is no need to call save. 
Note that update does not respect the checked-in status of nodes. An 
update may change a node even if it is currently checked-in (this fact is 
only relevant in an implementation that supports versioning, see 6.2 
Versioning). 
If the specified srcWorkspace does not exist, a 
NoSuchWorkspaceException is thrown. 
If the current session does not have sufficient permissions to perform 
the operation, then an AccessDeniedException is thrown. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
A LockException is thrown if a lock prevents the update. 
A RepositoryException is thrown if another error occurs. 

=== String getCorrespondingNodePath(String workspaceName) ===
Returns the absolute path of the node in the specified workspace that 
corresponds to this node. 
If no corresponding node exists then an ItemNotFoundException is 
thrown. 
If the specified workspace does not exist then a 
NoSuchWorkspaceException is thrown. 
If the current Session does not have sufficient permissions to perform 
this operation, an AccessDeniedException is thrown. 
Throws a RepositoryException if another error occurs. 

=== void orderBefore(String srcChildRelPath, String destChildRelPath) ===
If this node supports child node ordering, this method inserts the child 
node at srcChildRelPath before its sibling, the child node at 
destChildRelPath, in the child node list. To place the node 
srcChildRelPath at the end of the list, a destChildRelPath of null is 
used. 
Note that (apart from the case where destChildRelPath is null) both 
of these arguments must be relative paths of depth one, in other words 
they are the names of the child nodes, possibly suffixed with an index 
(see 3.6.1 Names vs. Paths). 
If srcChildRelPath and destChildRelPath are the same, then no change is made. 
Changes to ordering of child nodes are persisted on save of the parent 
node. 
If this node does not support child node ordering, then a 
UnsupportedRepositoryOperationException thrown. 
If srcChildRelPath is not the relative path to a child node of this node 
then an ItemNotFoundException is thrown. 
If destChildRelPath is neither the relative path to a child node of this 
node nor null, then an ItemNotFoundException is also thrown. 
A ConstraintViolationException will be thrown either immediately 
(by this method), or on save, if this operation would violate a 
implementation-specific constraint. Implementations may differ on when 
this validation is performed. 
A VersionException will be thrown either immediately (by this 
method), or on save, if this node is versionable and checked-in or is 
non-versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException will be thrown either immediately (by this method), or 
on save, if a lock prevents the re-ordering. Implementations may differ 
on when this validation is performed. 
If another error occurs a RepositoryException is thrown.  

=== void addMixin(String mixinName) ===
Adds the specified mixin node type to this node. Also adds mixinName to 
this node's jcr:mixinTypes property immediately. Semantically, the 
mixin node type assignment may take effect immediately and at the very 
least, it must take effect on save. 
A ConstraintViolationException is thrown either immediately or on 
save if a conflict with another assigned mixin or the primary node type 
or for an implementation-specific reason. Implementations may differ on 
when this validation is done. 
In some implementations it may only be possible to add mixin types 
before a node is first saved, and not after. In such cases any later calls 
to addMixin will throw a ConstraintViolationException either 
immediately or on save. 
If the specified mixin node type is not recognized a 
NoSuchNodeTypeException is thrown either immediately or on save. 
Implementations may differ on when this validation is done. 
A VersionException is thrown either immediately or on save if this 
node is versionable and checked-in, or is non-versionable but its nearest 
versionable ancestor is checked-in. Implementations may differ on when 
this validation is done. 
A LockException is thrown either immediately or on save if a lock 
prevents the addition of the mixin. Implementations may differ on when 
this validation is done. 
A RepositoryException will be thrown if another error occurs. 

=== void removeMixin(String mixinName) ===
Removes the specified mixin node type from this node. Also removes 
mixinName from this node's jcr:mixinTypes property immediately. 
Semantically, the mixin node type removal may take effect immediately 
and at the very least, it must take effect on save. 
If this node does not have the specified mixin, a 
NoSuchNodeTypeException is thrown either immediately or on save. 
Implementations may differ on when this validation is done. 
A ConstraintViolationException will be thrown either immediately or 
on save if the removal of a mixin is not allowed. Implementations are 
free to enforce any policy they like with regard to mixin removal and 
may differ on when this validation is done. 
A VersionException is thrown either immediately or on save if this 
node is versionable and checked-in or is non-versionable but its nearest 
versionable ancestor is checked-in. Implementations may differ on when 
this validation is done. 
A LockException is thrown either immediately or on save if a lock 
prevents the removal of the mixin. Implementations may differ on when 
this validation is done. 
A RepositoryException will be thrown if another error occurs. 

=== boolean canAddMixin(String mixinName) ===
Returns true if the specified mixin node type, mixinName, can be added 
to this node. Returns false otherwise. A result of false must be 
returned in each of the following cases: 
• The mixin's definition conflicts with an existing primary or mixin 
node type of this node. 
• This node is versionable and checked-in or is non-versionable and 
its nearest versionable ancestor is checked-in. 
• This node is protected (as defined in this node's NodeDefinition, 
found in the node type of this node's parent). 
• An access control restriction would prevent the addition of the 
mixin. 
• A lock would prevent the addition of the mixin. 
• An implementation-specific restriction would prevent the addition 
of the mixin. 
A NoSuchNodeTypeException is thrown if the specified mixin node type 
name is not recognized. 
A RepositoryException will be thrown if another error occurs. 
