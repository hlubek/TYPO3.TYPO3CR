== Session ==

=== void refresh(boolean keepChanges) ===
If keepChanges is false, this method discards all pending changes 
currently recorded in this Session and returns all items to reflect the 
current saved state. Outside a transaction this state is simply the 
current state of persistent storage. Within a transaction, this state will 
reflect persistent storage as modified by changes that have been saved 
but not yet committed. 
If keepChanges is true then pending changes are not discarded but 
items that do not have changes pending have their state refreshed to 
reflect the current saved state, thus revealing changes made by other 
sessions. In some implementations this may be a null operation. See 
5.1.3.4 Seeing Changes Made by Other Sessions, for more details. 
A RepositoryException is thrown if another error occurs. 

=== boolean hasPendingChanges() ===
Returns true if this Session holds pending (that is, unsaved) changes; 
otherwise returns false. 
A RepositoryException is thrown if an error occurs. 

=== ValueFactory getValueFactory() ===
This method returns a ValueFactory that is used to create Value 
objects for use when setting repository properties (see 5.1.5 Adding and 
Writing Properties and 5.1.5.3 Creating Value Objects). 
If writing to the repository is not supported (because this is a level 1-
only implementation, for example) an 
UnsupportedRepositoryOperationException will be thrown.

=== String move(String srcAbsPath, String destAbsPath) ===
Moves the node at srcAbsPath (and its entire subtree) to the new 
location at destAbsPath. Returns the path of the node at its new 
position. Note that the returned path will indicate the resulting same- 
name sibling index of the destination (if necessary), unlike the supplied 
destAbsPath parameter (see below). 
In order to persist the change, save must be called on either the 
session or a common ancestor to both the source and destination 
locations. 
A ConstraintViolationException is thrown either immediately (by 
this method) or on save if performing this operation would violate a 
node type or implementation-specific constraint. Implementations may 
differ on when this validation is performed. 
As well, a ConstraintViolationException will be thrown on save if an 
attempt is made to save only either the source or destination node 
separately. 
Note that this behavior differs from that of Workspace.move (see 
below), which operates directly in the persistent workspace and does 
not require a save. 
The destAbsPath provided must not have an index on its final element. 
If it does then a RepositoryException is thrown immediately. Strictly 
speaking, the destAbsPath parameter is actually an absolute path to 
the parent node of the new location, appended with the new name 
desired for the moved node. It does not specify a position within the 
child node ordering. If ordering is supported by the node type of the 
parent node of the new location, then the newly moved node is 
appended to the end of the child node list. The resulting position within 
a same-name sibling set can, however, be determined from the path 
returned by this method, which will include an index if one is required. 
This method cannot be used to move just an individual property by 
itself. It moves an entire node and its subtree (including, of course, any 
properties contained therein). 
If no node exists at srcAbsPath or no node exists one level above 
destAbsPath (in other words, there is no node that will serve as the 
parent of the moved item) then a PathNotFoundException is thrown 
either immediately or on save. Implementations may differ on when this 
validation is performed. 
An ItemExistsException is thrown either immediately or on save if a 
property already exists at destAbsPath or a node already exists there 
and same-name siblings are not allowed. Implementations may differ on 
when this validation is performed. 
A VersionException is thrown either immediately or on save if the 
parent node of destAbsPath or the parent node of srcAbsPath is 
versionable and checked-in, or is non-versionable and its nearest 
versionable ancestor is checked-in. Implementations may differ on when 
this validation is performed. 
A LockException is thrown either immediately or on save if a lock 
prevents the move. Implementations may differ on when this validation 
is performed. 
A RepositoryException is thrown if another error occurs. 

=== Workspace createWorkspace(String name) ===
Creates a new Workspace with the specified name and returns it. 
Throws an AccessDeniedException if this Session does not have 
permission to create the new Workspace. 
Throws an UnsupportedRepositoryOperationException if the 
repository does not support the creation of workspaces. 

=== void deleteWorkspace(String name) ===
Deletes the workspace with the specified name from the repository, 
deleting all content within it.  
Throws an AccessDeniedException if this Session does not have 
permission to remove the workspace. 
Throws an UnsupportedRepositoryOperationException if the 
repository does not support the removal of workspaces. 

=== ContentHandler getImportContentHandler(String parentAbsPath, 
                        int uuidBehavior) ===
Returns an org.xml.sax.ContentHandler which can be used to push 
SAX events into the repository. If the incoming XML stream (in the form 
of SAX events) does not appear to be a system view XML document 
then it is interpreted as a document view XML document. 
The incoming XML is deserialized into a subtree of items immediately 
below the node at parentAbsPath. 
This method simply returns the ContentHandler without altering the 
state of the session; the actual deserialization to the session transient 
space is done through the methods of the ContentHandler. Invalid XML 
data will cause the ContentHandler to throw a SAXException. 
As SAX events are fed into the ContentHandler, the tree of new items 
is built in the transient storage of the session. In order to persist the 
new content, save must be called. The advantage of this through-the- 
session method is that (depending on what constraint checks the 
implementation leaves until save) structures that violate node type 
constraints can be imported, fixed and then saved. The disadvantage is 
that a large import will result in a large cache of pending nodes in the 
session. See Workspace.getImportContentHandler for a version of this 
method that does not go through the session. 
The flag uuidBehavior governs how the UUIDs of incoming 
(deserialized) nodes are handled. There are four options (defined as 
constants in the interface javax.jcr.ImportUUIDBehavior): 
• IMPORT_UUID_CREATE_NEW: Incoming referenceable nodes are 
added in the same way that new node is added with 
Node.addNode. That is, they are either assigned newly created 
UUIDs upon addition or upon save (depending on the 
implementation, see 3.9.1.1 When UUIDs are Assigned). In 
either case, UUID collisions will not occur. 
• IMPORT_UUID_COLLISION_REMOVE_EXISTING: If an incoming 
referenceable node has the same UUID as a node already 
existing in the workspace then the already existing node (and its 
subtree) is removed from wherever it may be in the workspace 
before the incoming node is added. Note that this can result in 
nodes “disappearing” from locations in the workspace that are 
remote from the location to which the incoming subtree is being 
written. Both the removal and the new addition will be persisted 
on save. 
• IMPORT_UUID_COLLISION_REPLACE_EXISTING: If an incoming 
referenceable node has the same UUID as a node already 
existing in the workspace, then the already-existing node is 
replaced by the incoming node in the same position as the 
existing node. Note that this may result in the incoming subtree 
being disaggregated and “spread around” to different locations in 
the workspace. In the most extreme case this behavior may 
result in no node at all being added as child of 
parentAbsPath. 
This will occur if the topmost element of the incoming XML has 
the same UUID as an existing node elsewhere in the workspace. 
The change will be persisted on save. 
• IMPORT_UUID_COLLISION_THROW: If an incoming referenceable 
node has the same UUID as a node already existing in the 
workspace then a SAXException is thrown by the 
ContentHandler during deserialization. Unlike 
Workspace.getImportContentHandler, this method does not 
necessarily enforce all node type constraints during deserialization. 
Those that would be immediately enforced in a normal write method 
(Node.addNode, Node.setProperty etc.) of this implementation cause 
the returned ContentHandler to throw an immediate SAXException 
during deserialization. All other constraints are checked on 
save, just as they are in normal write operations. However, which node type 
constraints are enforced also depends upon whether node type 
information in the imported data is respected, and this is an 
implementation-specific issue (see 5.4.3 Respecting Property 
Semantics). 
A SAXException will also be thrown by the returned ContentHandler 
during deserialization if uuidBehavior is set to 
IMPORT_UUID_COLLISION_REMOVE_EXISTING and an incoming node has 
the same UUID as the node at parentAbsPath or one of its ancestors. 
A PathNotFoundException is thrown either immediately or on save if 
no node exists at parentAbsPath. Implementations may differ on when 
this validation is performed. 
A ConstraintViolationException is thrown either immediately or on 
save if the new subtree cannot be added to the node at parentAbsPath 
due to node-type or other implementation-specific constraints. 
Implementations may differ on when this validation is performed. 
A VersionException is thrown either immediately or on save if the 
node at parentAbsPath is versionable and checked-in, or is non- 
versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException is thrown either immediately or on save if a lock 
prevents the addition of the subtree. Implementations may differ on 
when this validation is performed. 
A RepositoryException is thrown if another error occurs. 

=== void importXML(String parentAbsPath, 
          InputStream in, 
          int uuidBehavior) ===
Deserializes an XML document and adds the resulting item subtree as a 
child of the node at parentAbsPath. 
If the incoming XML stream does not appear to be a system view XML 
document then it is interpreted as a document view XML document. 
The passed InputStream is closed before this method returns either 
normally or because of an exception. 
The tree of new items is built in the transient storage of the 
Session. In order to persist the new content, save must be called. The advantage of 
this through-the- session method is that (depending on what constraint 
checks the implementation leaves until save) structures that violate 
node type constraints can be imported, fixed and then saved. The 
disadvantage is that a large import will result in a large cache of 
pending nodes in the session. See Workspace.importXML for a version 
of this method that does not go through the Session. 
The flag uuidBehavior governs how the UUIDs of incoming 
(deserialized) nodes are handled. There are four options (defined as 
constants in the interface javax.jcr.ImportUUIDBehavior): 
• IMPORT_UUID_CREATE_NEW: Incoming referenceable nodes are 
added in the same way that new node is added with 
Node.addNode. That is, they are either assigned newly created 
UUIDs upon addition or upon save (depending on the 
implementation, see 3.9.1.1 When UUIDs are Assigned). In 
either case, UUID collisions will not occur. 
• IMPORT_UUID_COLLISION_REMOVE_EXISTING: If an incoming 
referenceable node has the same UUID as a node already 
existing in the workspace then the already existing node (and its 
subtree) is removed from wherever it may be in the workspace 
before the incoming node is added. Note that this can result in 
nodes “disappearing” from locations in the workspace that are 
remote from the location to which the incoming subtree is being 
written. Both the removal and the new addition will be persisted 
on save. 
• IMPORT_UUID_COLLISION_REPLACE_EXISTING: If an incoming 
referenceable node has the same UUID as a node already 
existing in the workspace, then the already-existing node is 
replaced by the incoming node in the same position as the 
existing node. Note that this may result in the incoming subtree 
being disaggregated and “spread around” to different locations in 
the workspace. In the most extreme case this behavior may 
result in no node at all being added as child of parentAbsPath. 
This will occur if the topmost element of the incoming XML has 
the same UUID as an existing node elsewhere in the workspace. 
The change will be persisted on save. 
• IMPORT_UUID_COLLISION_THROW: If an incoming referenceable 
node has the same UUID as a node already existing in the 
workspace then an ItemExistsException is thrown. 
Unlike Workspace.importXML, this method does not necessarily enforce 
all node type constraints during deserialization. Those that would be 
immediately enforced in a normal write method (Node.addNode, 
Node.setProperty etc.) of this implementation cause an immediate 
ConstraintViolationException during deserialization. All other 
constraints are checked on save, just as they are in normal write 
operations. However, which node type constraints are enforced depends 
upon whether node type information in the imported data is respected, 
and this is an implementation-specific issue (see 5.4.3 Respecting 
Property Semantics). 
A ConstraintViolationException will also be thrown immediately if 
uuidBehavior is set to IMPORT_UUID_COLLISION_REMOVE_EXISTING and 
an incoming node has the same UUID as the node at 
parentAbsPath or one of its ancestors. 
A PathNotFoundException is thrown either immediately or on save if 
no node exists at parentAbsPath. Implementations may differ on when 
this validation is performed. 
A VersionException is thrown either immediately or on save if the 
node at parentAbsPath is versionable and checked-in, or is non- 
versionable but its nearest versionable ancestor is checked-in. 
Implementations may differ on when this validation is performed. 
A LockException is thrown either immediately or on save if a lock 
prevents the addition of the subtree. Implementations may differ on 
when this validation is performed. 
A RepositoryException is thrown if another error occurs. 
