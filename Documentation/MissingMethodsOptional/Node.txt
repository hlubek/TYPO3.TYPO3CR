== Node ==

=== Version checkin() ===
Creates a new version with a system generated name and returns that 
version. The jcr:isCheckedOut property of this node is set to false 
thus putting the node into the checked-in state. This means that this 
node and its connected non-versionable subtree become read-only. A 
node's connected non-versionable subtree is the set of non-versionable 
descendant nodes reachable from that node through child links without 
encountering any versionable nodes. In other words, the read-only 
status flows down from the checked-in node along every child link until 
either a versionable node is encountered or an item with no children is 
encountered. 
Read-only status means that an item cannot be altered by the client 
using standard API methods (addNode, setProperty, etc.). The only 
exceptions to this rule are the restore20, Node.merge and Node.update 
operations; these do not respect read-only status due to check-in. Note 
that remove of a read-only node is possible, as long as its parent is not 
read-only (since removal is an alteration of the parent node). 
See 6.2.5 Check In for more details. 
If this node is already checked-in, this method has no effect but returns 
the current base version of this node. If this node is not versionable, an 
UnsupportedRepositoryOperationException is thrown. 
A VersionException is thrown or if a child item of this node has an 
OnParentVersion status of ABORT. This includes the case where an 
unresolved merge failure exists on this node, as indicated by the 
presence of the jcr:mergeFailed property. 
If checkin succeeds, the change to the jcr:checkedOut property is 
automatically persisted (there is no need to do an additional 
save). 
If there are unsaved changes pending on this node, an 
InvalidItemStateException is thrown. 
A LockException is thrown if a lock prevents the operation. 
A RepositoryException is thrown if another error occurs.  

=== void checkout() ===
Sets this versionable node to checked-out status by setting its 
jcr:isCheckedOut property to true, sets the jcr:predecessors 
property to be a reference to the current base version (the same value 
as held in jcr:baseVersion). This method puts the node into the 
checked-out state, making it and its connected non-versionable subtree 
no longer read-only (see checkin, above, for an explanation of the term 
“connected non-versionable subtree”). 
If successful, these changes are persisted immediately, there is no need 
to call save. See 6.2.6 Check Out for more details. 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
A LockException is thrown if a lock prevents the operation. 
A RepositoryException is thrown if another error occurs.  

=== void checkpoint() ===
Performs a checkin() followed by a checkout(). 
If this node is already checked-in, this method is equivalent to 
checkout(). 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
A VersionException is thrown or if a child item of this node has an 
OnParentVersion status of ABORT. This includes the case where an 
unresolved merge failure exists on this node, as indicated by the 
presence of the jcr:mergeFailed property. 
If there are unsaved changes pending on this node, an 
InvalidItemStateException is thrown. 
A LockException is thrown if a lock prevents the operation. 
A RepositoryException is thrown if another error occurs. 

=== NodeIterator merge(String srcWorkspace, boolean bestEffort) ===
This method can be thought of as a version-sensitive update (see 7.1.8 
Updating and Cloning Nodes across Workspaces). 
It recursively tests each versionable node in the subtree of this node 
against its corresponding node in srcWorkspace with respect to the 
relation between their respective base versions and either updates the 
node in question or not, depending on the outcome of the test. For 
details see 6.2.11 Merge. 
A MergeException is thrown if bestEffort is false and a versionable 
node is encountered whose corresponding node's base version is on a 
divergent branch from this node's base version. 
If successful, the changes are persisted immediately, there is no need to 
call save. 
This method returns a NodeIterator over all versionable nodes in the 
subtree that received a merge result of fail. If bestEffort is false, this 
iterator will be empty (since if it merge returns successfully, instead of 
throwing an exception, it will be because no failures were encountered). 
If bestEffort is true, this iterator will contain all nodes that received a 
fail during the course of this merge operation. 
If the specified srcWorkspace does not exist, a NoSuchWorkspaceException is thrown. 
If the current session does not have sufficient permissions to perform 
the operation, then an AccessDeniedException is thrown. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
A LockException is thrown if a lock prevents the merge. 
A RepositoryException is thrown if another error occurs.  

=== NodeIterator merge(Node activityNode) ===
Used to import the changes described by an activity into another 
workspace. The effect of this method is equivalent to performing a 
shallow merge of each activity version into the corresponding node in 
this workspace. If there is no corresponding node in this workspace for a 
given activity version, that version is ignored. 
A MergeException is thrown in the same cases as in a regular shallow 
merge. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
A LockException is thrown if a lock prevents the merge. 
A RepositoryException is thrown if another error occurs. 

=== void doneMerge(Version version) ===
Completes the merge process with respect to this node and the specified 
version. See 6.2.11 Merge for more details. 
If successful, the changes are persisted immediately, there is no need to 
call save. 
A VersionException is thrown if the version specified is not among 
those referenced in this node's jcr:mergeFailed property or if this node 
is currently checked-in. 
An UnsupportedRepositoryOperationException is thrown if this node 
is not versionable. 
If there are unsaved changes pending on this node, an 
InvalidItemStateException is thrown. 
A LockException is thrown if a lock prevents the operation. 
A RepositoryException is thrown if another error occurs.  

=== void cancelMerge(Version version) ===
Cancels the merge process with respect to this node and the specified 
version. See 6.2.11 Merge for more details. 
If successful, the changes are persisted immediately, there is no need to 
call save. 
A VersionException is thrown if the version specified is not among 
those referenced in this node's jcr:mergeFailed property or if this node 
is currently checked-in. 
An UnsupportedRepositoryOperationException is thrown if this node 
is not versionable. 
If there are unsaved changes pending on this node, an 
InvalidItemStateException is thrown. 
A LockException is thrown if a lock prevents the operation. 
A RepositoryException is thrown if another error occurs.  

=== boolean isCheckedOut() ===
Returns true if this node is either 
• versionable and currently checked-out, 
• non-versionable and its nearest versionable ancestor is checked-out or 
• non-versionable and it has no versionable ancestor. 
Returns false if this node is either 
• versionable and currently checked-in or 
• non-versionable and its nearest versionable ancestor is checked-in. 
A RepositoryException is thrown if an error occurs.  

=== void restore(String versionName, 
        boolean removeExisting) ===
Restores this node to the state defined by the version with the specified 
versionName. 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
If successful, the change is persisted immediately and there is no need 
to call save. 
A VersionException is thrown if no version with the specified 
versionName exists in this node's version history or if an attempt is 
made to restore the root version (jcr:rootVersion). 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
This method will work regardless of whether this node is checked-in or 
not. 
A UUID collision occurs when a node exists outside the subtree rooted at 
this node with the same UUID as a node that would be introduced by the 
restore operation into the subtree at this node. The result in such a 
case is governed by the removeExisting flag. If removeExisting is 
true, then the incoming node takes precedence, and the existing node 
(and its subtree) is removed. If removeExisting is false, then a 
ItemExistsException is thrown and no changes are made. Note that 
this applies not only to cases where the restored node itself conflicts 
with an existing node but also to cases where a conflict occurs with any 
node that would be introduced into the workspace by the restore 
operation. In particular conflicts involving subnodes of the restored node 
that have OnParentVersion settings of COPY or VERSION (see 6.2.12 
OnParentVersion Attribute) are also governed by the removeExisting flag. 
A LockException is thrown if a lock prevents the restore. 
A RepositoryException is thrown if another error occurs.  

=== void restore(Version version, boolean removeExisting) ===
Restores this node to the state defined by the specified version. 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
If successful, the change is persisted immediately and there is no need 
to call save. 
A VersionException is thrown if the specified version is not part of this 
node's version history. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
This method will work regardless of whether this node is checked-in or 
not. 
A UUID collision occurs when a node exists outside the subtree rooted at 
this node with the same UUID as a node that would be introduced by the 
restore operation into the subtree at this node. The result in such a 
case is governed by the removeExisting flag. If removeExisting is 
true, then the incoming node takes precedence, and the existing node 
(and its subtree) is removed. If removeExisting is false, then a 
ItemExistsException is thrown and no changes are made. Note that 
this applies not only to cases where the restored node itself conflicts 
with an existing node but also to cases where a conflict occurs with any 
node that would be introduced into the workspace by the restore 
operation. In particular conflicts involving subnodes of the restored node 
that have OnParentVersion settings of COPY or VERSION (see 6.2.12 
OnParentVersion Attribute) are also governed by the 
removeExisting flag. 
A LockException is thrown if a lock prevents the restore. 
A RepositoryException is thrown if another error occurs.  

=== void restore(Version version, 
        String relPath, 
        boolean removeExisting) ===
Restores the specified version to relPath, relative to this node. 
A node need not exist at relPath, though the parent of relPath must 
exist, otherwise a PathNotFoundException is thrown. 
If a node does exist at relPath then it must correspond to the version 
being restored (the version must be a version of that node), otherwise a 
VersionException is thrown. If no node exists at 
relPath then a VersionException is thrown if the parent node of 
relPath is versionable and checked-in or is non- 
versionable but its nearest versionable ancestor is checked-in. 
If there is a node at relPath then the checked-in status of that node 
itself and the checked-in status of its parent are irrelevant. The restore 
will work even if one or both are checked-in. 
A UUID collision occurs when a node exists outside the subtree rooted at 
relPath with the same UUID as a node that would be introduced by the 
restore operation into the subtree at relPath (note that in cases where 
there is no node at relPath, this amounts to saying that a UUID 
collision occurs if there exists a node anywhere in this workspace with 
the same UUID as a node that would be introduced by the 
restore). 
The result in such a case is governed by the removeExisting flag. If 
removeExisting is true then the incoming node takes precedence, and 
the existing node (and its subtree) is removed. If removeExisting is 
false, then a ItemExistsException is thrown and no changes are 
made. Note that this applies not only to cases where the restored node 
itself conflicts with an existing node but also to cases where a conflict 
occurs with any node that would be introduced into the workspace by 
the restore operation. In particular conflicts involving subnodes of the 
restored node that have OnParentVersion settings of COPY or VERSION 
(see 6.2.12 OnParentVersion Attribute) are also governed by the 
removeExisting flag. 
If the would-be parent of the location relPath is actually a property, or 
if a node type restriction would be violated, then a 
ConstraintViolationException is thrown. 
If the restore succeeds, the changes made to this node are persisted 
immediately, there is no need to call save. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
An UnsupportedRepositoryOperationException is thrown if versioning 
is not supported. 
A LockException is thrown if a lock prevents the restore. 
A RepositoryException is thrown if another error occurs.  

=== void restoreByLabel(String versionLabel, boolean removeExisting) ===
Restores this node to the state defined by the version with the specified 
versionLabel. 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
If successful, the change is persisted immediately and there is no need 
to call save. 
A VersionException is thrown if no version with the specified 
versionLabel exists in this node's version history. 
This method will work regardless of whether this node is checked-in or 
not. 
A UUID collision occurs when a node exists outside the subtree rooted at 
this node with the same UUID as a node that would be introduced by the 
restore operation into the subtree at this node. The result in such a 
case is governed by the removeExisting flag. If removeExisting is 
true, then the incoming node takes precedence, and the existing node 
(and its subtree) is removed. If removeExisting is false, then a 
ItemExistsException is thrown and no changes are made. Note that 
this applies not only to cases where the restored node itself conflicts 
with an existing node but also to cases where a conflict occurs with any 
node that would be introduced into the workspace by the restore 
operation. In particular conflicts involving subnodes of the restored node 
that have OnParentVersion settings of COPY or VERSION (see 6.2.12 
OnParentVersion Attribute) are also governed by the 
removeExisting flag. 
An InvalidItemStateException is thrown if this Session (not 
necessarily this Node) has pending unsaved changes. 
A LockException is thrown if a lock prevents the restore. 
A RepositoryException is thrown if another error occurs.  

=== VersionHistory getVersionHistory() ===
Returns the VersionHistory object of this node. This object provides 
access to the nt:versionHistory node holding this node's versions. 
If this node is not versionable, an 
UnsupportedRepositoryOperationException is thrown. 
A RepositoryException is thrown if another error occurs.  

=== Version getBaseVersion() ===
Returns the current base version of this versionable node. 
If this node is not versionable, an UnsupportedRepositoryOperationException is thrown. 
A RepositoryException is thrown if another error occurs.  

=== Node createActivity(String title) ===
This method is applied to either the /jcr:system/jcr:activities  
node or one of its children (if the repository allows or provides activity 
folder nodes). The repository may (but is not required to) use the 
title as a hint for what to name the new activity node. The new activity 
Node is returned.  
An UnsupportedRepositoryOperationException is thrown if the 
repository does not support activities. 
A RepositoryException is thrown if another error occurs. 

=== Lock lock(boolean isDeep, boolean isSessionScoped) ===
Places a lock on this node. If successful, this node is said to hold the 
lock. 
If isDeep is true then the lock applies to this node and all its 
descendant nodes; if false, the lock applies only to this, the holding 
node. 
If isSessionScoped is true then this lock will expire upon the 
expiration of the current session (either through an automatic or explicit 
Session.logout); if false, this lock does not expire until explicitly 
unlocked or automatically unlocked due to a implementation-specific 
limitation, such as a timeout. 
Returns a Lock object reflecting the state of the new lock and including 
a lock token. 
The lock token is also automatically added to the set of lock tokens held 
by the current Session. 
If successful, then the property jcr:lockOwner is created and set to the 
value of Session.getUserID for the current session and the property 
jcr:lockIsDeep is set to the value passed in as isDeep. These changes 
are persisted automatically; there is no need to call save. 
Note that it is possible to lock a node even if it is checked-in (the lock- 
related properties will be changed despite the checked-in status). See 
8.2 Versioning for an explanation of “checked-in” status. 
If this node is not of mixin node type mix:lockable then a 
LockException is thrown. 
If this node is already locked (either because it holds a lock or a lock 
above it applies to it), a LockException is thrown. 
If isDeep is true and a descendant node of this node already holds a 
lock, then a LockException is thrown. 
If this node does not have a persistent state (has never been saved or 
otherwise persisted), a LockException is thrown. 
If the current session does not have sufficient permissions to place the 
lock, an AccessDeniedException is thrown. 
An InvalidItemStateException is thrown if this node has pending 
unsaved changes. 
An UnsupportedRepositoryOperationException is thrown if this 
implementation does not support locking. 
A RepositoryException is thrown if another error occurs. 

=== Lock getLock() ===
Returns the Lock object that applies to this node. This may be either a 
lock on this node itself or a deep lock on a node above this node. 
If this Session (the one through which this Node was acquired) holds 
the lock token for this lock, then the returned 
Lock object contains that lock token (accessible through 
Lock.getLockToken). If this Session 
does not hold the applicable lock token, then the returned 
Lock object will not contain the lock token (its 
Lock.getLockToken method will return 
null). See Lock, below. 
If this node is not locked (no lock applies to this node) then a 
LockException is thrown. 
If the current session does not have sufficient permissions to get the 
lock, an AccessDeniedException is thrown. 
An UnsupportedRepositoryOperationException is thrown if this 
implementation does not support locking. 
A RepositoryException is thrown if another error occurs. 

=== void unlock() ===
Removes the lock on this node. Also removes the properties 
jcr:lockOwner and jcr:lockIsDeep from this node. These changes are 
persisted automatically; there is no need to call save. 
As well, the corresponding lock token is removed from the set of lock 
tokens held by the current Session. 
If this node does not currently hold a lock or holds a lock for which this 
Session does not have the correct lock token, then a LockException is 
thrown. Note however that the system may give permission to some 
users to unlock locks for which they do not have the lock token. 
Typically such “lock-superuser” capability is intended to facilitate 
administrational clean-up of orphaned open-scoped locks. 
Note also that it is possible to unlock a node even if it is checked-in (the 
lock-related properties will be changed despite the checked-in status). 
See 8.2 Versioning for an explanation of “checked-in” status. 
If the current session does not have sufficient permissions to remove 
the lock, an AccessDeniedException is thrown. 
An InvalidItemStateException is thrown if this node has pending 
unsaved changes. 
An UnsupportedRepositoryOperationException is thrown if this 
implementation does not support locking. 
A RepositoryException is thrown if another error occurs. 

=== boolean holdsLock() ===
Returns true if this node holds a lock; otherwise returns false. To hold 
a lock means that this node has actually had a lock placed on it 
specifically, as opposed to just having a lock apply to it due to a deep 
lock held by an node above. 
A RepositoryException is thrown if an error occurs. 

=== boolean isLocked() ===
Returns true if this node is locked either as a result of a lock held by 
this node or by a deep lock on a node above this node; otherwise 
returns false. 
A RepositoryException is thrown if an error occurs. 

=== boolean followTransition(String transition) ===
Returns true if the operation to follow the specified transition is 
successful. Returns false otherwise. 
Throws an UnsupportedRepositoryOperationException if this 
implementation does not support lifecycle actions. 
Throws an WrongNodeTypeException if this node does not have the 
mix:lifecycle mixin. 
Throws a RepositoryException if another error occurs. 

=== String[] getAllowedStateTransitions() ===
Returns the list of valid state transitions for this node. 
Throws an UnsupportedRepositoryOperationException if this 
implementation does not support lifecycle actions. 
Throws an WrongNodeTypeException if this node does not have the 
mix:lifecycle mixin. 
Throws a RepositoryException if another error occurs. 
